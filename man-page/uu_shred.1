.ie \n(.g .ds Aq \(aq
.el .ds Aq '
.TH uu_shred 1  "uu_shred 0.0.27" 
.SH NAME
uu_shred \- Overwrite the specified FILE(s) repeatedly, in order to make it harder for even
very expensive hardware probing to recover the data.
.SH SYNOPSIS
\fBuu_shred\fR [\fB\-f\fR|\fB\-\-force\fR] [\fB\-n\fR|\fB\-\-iterations\fR] [\fB\-s\fR|\fB\-\-size\fR] [\fB\-u \fR] [\fB\-\-remove\fR] [\fB\-v\fR|\fB\-\-verbose\fR] [\fB\-x\fR|\fB\-\-exact\fR] [\fB\-z\fR|\fB\-\-zero\fR] [\fB\-h\fR|\fB\-\-help\fR] [\fB\-V\fR|\fB\-\-version\fR] [\fIfile\fR] 
.SH DESCRIPTION
Overwrite the specified FILE(s) repeatedly, in order to make it harder for even
very expensive hardware probing to recover the data.
.SH OPTIONS
.TP
\fB\-f\fR, \fB\-\-force\fR
change permissions to allow writing if necessary
.TP
\fB\-n\fR, \fB\-\-iterations\fR=\fINUMBER\fR [default: 3]
overwrite N times instead of the default (3)
.TP
\fB\-s\fR, \fB\-\-size\fR=\fIN\fR
shred this many bytes (suffixes like K, M, G accepted)
.TP
\fB\-u\fR
deallocate and remove file after overwriting
.TP
\fB\-\-remove\fR=\fIHOW\fR
like \-u but give control on HOW to delete;  See below
.br

.br
[\fIpossible values: \fRunlink, wipe, wipesync]
.TP
\fB\-v\fR, \fB\-\-verbose\fR
show progress
.TP
\fB\-x\fR, \fB\-\-exact\fR
do not round file sizes up to the next full block;
this is the default for non\-regular files
.TP
\fB\-z\fR, \fB\-\-zero\fR
add a final overwrite with zeros to hide shredding
.TP
\fB\-h\fR, \fB\-\-help\fR
Print help
.TP
\fB\-V\fR, \fB\-\-version\fR
Print version
.TP
[\fIfile\fR]

.SH EXTRA
Delete FILE(s) if \-\-remove (\-u) is specified.  The default is not to remove
the files because it is common to operate on device files like /dev/hda, and
those files usually should not be removed.

CAUTION: Note that shred relies on a very important assumption: that the file
system overwrites data in place.  This is the traditional way to do things, but
many modern file system designs do not satisfy this assumption.  The following
are examples of file systems on which shred is not effective, or is not
guaranteed to be effective in all file system modes:

 * log\-structured or journal file systems, such as those supplied with
   AIX and Solaris (and JFS, ReiserFS, XFS, Ext3, etc.)

 * file systems that write redundant data and carry on even if some writes
   fail, such as RAID\-based file systems

 * file systems that make snapshots, such as Network Appliance\*(Aqs NFS server

 * file systems that cache in temporary locations, such as NFS
   version 3 clients

 * compressed file systems

In the case of ext3 file systems, the above disclaimer applies (and shred is
thus of limited effectiveness) only in data=journal mode, which journals file
data in addition to just metadata.  In both the data=ordered (default) and
data=writeback modes, shred works as usual. Ext3 journal modes can be changed
by adding the data=something option to the mount options for a particular
file system in the /etc/fstab file, as documented in the mount man page (man
mount).

In addition, file system backups and remote mirrors may contain copies of
the file that cannot be removed, and that will allow a shredded file to be
recovered later.
.SH VERSION
v0.0.27
